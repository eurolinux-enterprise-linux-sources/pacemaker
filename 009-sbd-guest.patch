From 6f7ce4e903eed136cc9038952f9d57d4423736dd Mon Sep 17 00:00:00 2001
From: Klaus Wenninger <klaus.wenninger@aon.at>
Date: Sun, 4 Nov 2018 23:15:58 +0100
Subject: [PATCH 1/2] Refactor: remote_ra: have attribute strings in msg_xml.h

---
 crmd/remote_lrmd_ra.c | 6 +++---
 include/crm/msg_xml.h | 3 +++
 2 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/crmd/remote_lrmd_ra.c b/crmd/remote_lrmd_ra.c
index 3cdc7f0..a164fc1 100644
--- a/crmd/remote_lrmd_ra.c
+++ b/crmd/remote_lrmd_ra.c
@@ -724,10 +724,10 @@ handle_remote_ra_start(lrm_state_t * lrm_state, remote_ra_cmd_t * cmd, int timeo
     int timeout_used = timeout_ms > MAX_START_TIMEOUT_MS ? MAX_START_TIMEOUT_MS : timeout_ms;
 
     for (tmp = cmd->params; tmp; tmp = tmp->next) {
-        if (safe_str_eq(tmp->key, "addr") || safe_str_eq(tmp->key, "server")) {
+        if (safe_str_eq(tmp->key, XML_RSC_ATTR_REMOTE_RA_ADDR) ||
+            safe_str_eq(tmp->key, XML_RSC_ATTR_REMOTE_RA_SERVER)) {
             server = tmp->value;
-        }
-        if (safe_str_eq(tmp->key, "port")) {
+        } else if (safe_str_eq(tmp->key, XML_RSC_ATTR_REMOTE_RA_PORT)) {
             port = atoi(tmp->value);
         }
     }
diff --git a/include/crm/msg_xml.h b/include/crm/msg_xml.h
index 1ac4302..55f42c4 100644
--- a/include/crm/msg_xml.h
+++ b/include/crm/msg_xml.h
@@ -233,6 +233,9 @@
 #  define XML_RSC_ATTR_REMOTE_NODE  	"remote-node"
 #  define XML_RSC_ATTR_CLEAR_OP         "clear_failure_op"
 #  define XML_RSC_ATTR_CLEAR_INTERVAL   "clear_failure_interval"
+#  define XML_RSC_ATTR_REMOTE_RA_ADDR   "addr"
+#  define XML_RSC_ATTR_REMOTE_RA_SERVER "server"
+#  define XML_RSC_ATTR_REMOTE_RA_PORT   "port"
 
 #  define XML_REMOTE_ATTR_RECONNECT_INTERVAL "reconnect_interval"
 
-- 
1.8.3.1


From 4dae6746002b034868feda763a85de85e08834e7 Mon Sep 17 00:00:00 2001
From: Klaus Wenninger <klaus.wenninger@aon.at>
Date: Sun, 4 Nov 2018 23:54:11 +0100
Subject: [PATCH 2/2] Fix: pacemaker-remote: skip remote_config_check for
 guest-nodes

This is crucial when watchdog-fencing is enabled as the sbd-check
done by pacemaker-remote would fail on guest-containers & bundles
(eventually tearing down pacemaker-remote inside the container)
and even on system-virtualized-guests the sbd-check doesn't make
sense as these guests would be fenced by stop/start-cycling the
VM.
---
 crmd/crmd_lrm.h       |  1 +
 crmd/lrm_state.c      | 14 +++++++++-----
 crmd/remote_lrmd_ra.c | 20 ++++++++++++++++++++
 3 files changed, 30 insertions(+), 5 deletions(-)

diff --git a/crmd/crmd_lrm.h b/crmd/crmd_lrm.h
index 7a74f7a..d115056 100644
--- a/crmd/crmd_lrm.h
+++ b/crmd/crmd_lrm.h
@@ -168,5 +168,6 @@ void remote_ra_fail(const char *node_name);
 void remote_ra_process_pseudo(xmlNode *xml);
 gboolean remote_ra_is_in_maintenance(lrm_state_t * lrm_state);
 void remote_ra_process_maintenance_nodes(xmlNode *xml);
+gboolean remote_ra_controlling_guest(lrm_state_t * lrm_state);
 
 gboolean process_lrm_event(lrm_state_t * lrm_state, lrmd_event_data_t * op, struct recurring_op_s *pending);
diff --git a/crmd/lrm_state.c b/crmd/lrm_state.c
index 497afe1..40da762 100644
--- a/crmd/lrm_state.c
+++ b/crmd/lrm_state.c
@@ -500,11 +500,15 @@ crmd_remote_proxy_cb(lrmd_t *lrmd, void *userdata, xmlNode *msg)
         const char *channel = crm_element_value(msg, F_LRMD_IPC_IPC_SERVER);
 
         proxy = crmd_remote_proxy_new(lrmd, lrm_state->node_name, session, channel);
-        if (proxy != NULL) {
-            /* Look up stonith-watchdog-timeout and send to the remote peer for validation */
-            int rc = fsa_cib_conn->cmds->query(fsa_cib_conn, XML_CIB_TAG_CRMCONFIG, NULL, cib_scope_local);
-            fsa_cib_conn->cmds->register_callback_full(fsa_cib_conn, rc, 10, FALSE, lrmd,
-                                                       "remote_config_check", remote_config_check, NULL);
+        if (!remote_ra_controlling_guest(lrm_state)) {
+            if (proxy != NULL) {
+                /* Look up stonith-watchdog-timeout and send to the remote peer for validation */
+                int rc = fsa_cib_conn->cmds->query(fsa_cib_conn, XML_CIB_TAG_CRMCONFIG, NULL, cib_scope_local);
+                fsa_cib_conn->cmds->register_callback_full(fsa_cib_conn, rc, 10, FALSE, lrmd,
+                                                        "remote_config_check", remote_config_check, NULL);
+            }
+        } else {
+            crm_debug("Skipping remote_config_check for guest-nodes");
         }
 
     } else if (safe_str_eq(op, LRMD_IPC_OP_SHUTDOWN_REQ)) {
diff --git a/crmd/remote_lrmd_ra.c b/crmd/remote_lrmd_ra.c
index a164fc1..0414709 100644
--- a/crmd/remote_lrmd_ra.c
+++ b/crmd/remote_lrmd_ra.c
@@ -85,6 +85,15 @@ typedef struct remote_ra_data_s {
                               * so we have it signalled back with the
                               * transition from pengine
                               */
+    gboolean controlling_guest; /* Similar for if we are controlling a guest
+                                 * or a bare-metal remote.
+                                 * Fortunately there is a meta-attribute in
+                                 * the transition already and as the
+                                 * situation doesn't change over time we can
+                                 * use the resource start for noting down
+                                 * the information for later use when the
+                                 * attributes aren't at hand.
+                                 */
 } remote_ra_data_t;
 
 static int handle_remote_ra_start(lrm_state_t * lrm_state, remote_ra_cmd_t * cmd, int timeout_ms);
@@ -721,6 +730,7 @@ handle_remote_ra_start(lrm_state_t * lrm_state, remote_ra_cmd_t * cmd, int timeo
     const char *server = NULL;
     lrmd_key_value_t *tmp = NULL;
     int port = 0;
+    remote_ra_data_t *ra_data = lrm_state->remote_ra_data;
     int timeout_used = timeout_ms > MAX_START_TIMEOUT_MS ? MAX_START_TIMEOUT_MS : timeout_ms;
 
     for (tmp = cmd->params; tmp; tmp = tmp->next) {
@@ -729,6 +739,8 @@ handle_remote_ra_start(lrm_state_t * lrm_state, remote_ra_cmd_t * cmd, int timeo
             server = tmp->value;
         } else if (safe_str_eq(tmp->key, XML_RSC_ATTR_REMOTE_RA_PORT)) {
             port = atoi(tmp->value);
+        } else if (safe_str_eq(tmp->key, CRM_META"_"XML_RSC_ATTR_CONTAINER)) {
+            ra_data->controlling_guest = TRUE;
         }
     }
 
@@ -1262,3 +1274,11 @@ remote_ra_is_in_maintenance(lrm_state_t * lrm_state)
 
     return ra_data->is_maintenance;
 }
+
+gboolean
+remote_ra_controlling_guest(lrm_state_t * lrm_state)
+{
+    remote_ra_data_t *ra_data = lrm_state->remote_ra_data;
+
+    return ra_data->controlling_guest;
+}
-- 
1.8.3.1

